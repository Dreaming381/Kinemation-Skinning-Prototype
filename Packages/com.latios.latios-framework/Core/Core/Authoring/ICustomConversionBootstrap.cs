using System.Collections.Generic;
using System.Reflection;
using static Unity.Entities.GameObjectConversionUtility;
using Unity.Entities;

namespace Latios.Authoring
{
    public delegate void OnPostCreateConversionWorldDelegate(World world, CustomConversionSettings settings);

    /// <summary>
    /// A subset of the settings provided to GameObject Conversion.
    /// These settings are populated by Unity and some may not be populated at all.
    /// </summary>
    public struct CustomConversionSettings
    {
        public World                                   destinationWorld;
        public Hash128                                 sceneGUID;
        public string                                  debugConversionName;
        public ConversionFlags                         conversionFlags;
        public OnPostCreateConversionWorldEventWrapper OnPostCreateConversionWorldWrapper;
        internal void InvokePostCreateConversionWorldEvent() => OnPostCreateConversionWorldWrapper.InvokePostCreateConversionWorldEvent(destinationWorld, this);
#if UNITY_EDITOR
        public UnityEditor.GUID buildConfigurationGUID;
        public Unity.Build.BuildConfiguration buildConfiguration;
        public UnityEditor.AssetImporters.AssetImportContext assetImportContext;
        public UnityEngine.GameObject prefabRoot;
#endif
    }

    /// <summary>
    /// Implement this interface in a bootstrap to customize the conversion world similar to runtime ICustomBootstrap.
    /// </summary>
    public interface ICustomConversionBootstrap
    {
        /// <summary>
        /// This function behaves similarly to ICustomBootstrap in that you can customize the conversion process
        /// at startup. However, unlike ICustomBootstrap, the World and top-level ComponentSystemGroups already
        /// exist when this method is called.
        /// </summary>
        /// <param name="conversionWorldWithGroupsAndMappingSystems">The auto-generated conversion world.</param>
        /// <param name="settings">Settings generated by Unity for the conversion operation. Some values may not be populated.</param>
        /// <param name="filteredSystems">
        /// The list of filtered systems initially contains the systems Unity would have otherwise added.
        /// Modify or replace the list to change the systems to add if returning false.
        /// If returning true, the result of any modification is ignored.
        /// </param>
        /// <returns>
        /// Return true if this function created all the conversion world systems.
        /// Return false if Unity should create them from the settings after this function returns.
        /// </returns>
        bool InitializeConversion(World conversionWorldWithGroupsAndMappingSystems, CustomConversionSettings settings, ref List<System.Type> filteredSystems);
    }

    public static class GameObjectConversionGetSettingsExtension
    {
        /// <summary>
        /// Retrieves a subset of the settings provided to  GameObject Conversion
        /// </summary>
        public static CustomConversionSettings GetSettings(this GameObjectConversionSystem system)
        {
            return system.World.GetExistingSystem<ConversionBootstrapUtilities.CustomConversionBootstrapSystem>().customConversionSettings;
        }
    }

    public class OnPostCreateConversionWorldEventWrapper
    {
        public event OnPostCreateConversionWorldDelegate OnPostCreateConversionWorld;
        internal void InvokePostCreateConversionWorldEvent(World destinationWorld, CustomConversionSettings settings) => OnPostCreateConversionWorld?.Invoke(destinationWorld,
                                                                                                                                                             settings);
    }

#if UNITY_EDITOR
    [UnityEditor.InitializeOnLoad]
#endif
    internal static class ConversionBootstrapUtilities
    {
        static ConversionBootstrapUtilities()
        {
            RegisterConversionWorldAction();
        }

        static bool m_isRegistered = false;

        internal static void RegisterConversionWorldAction()
        {
            if (!m_isRegistered)
            {
                m_isRegistered                                                = true;
                Unity.Entities.Exposed.WorldExposedExtensions.OnWorldCreated += InitializeConversionWorld;
            }
        }

        static void InitializeConversionWorld(World conversionWorldWithoutSystems)
        {
            if (!conversionWorldWithoutSystems.Flags.HasFlag(WorldFlags.Conversion))
                return;

            conversionWorldWithoutSystems.GetOrCreateSystem<CustomConversionBootstrapDetectorSystem>();
        }

        [DisableAutoCreation]
        class CustomConversionBootstrapDetectorSystem : ComponentSystem
        {
            bool bootstrapRan = false;

            protected override void OnCreate()
            {
                Unity.Entities.Exposed.WorldExposedExtensions.OnSystemCreated += CreateBootstrapSystem;
            }

            protected override void OnDestroy()
            {
                if (!bootstrapRan)
                    Unity.Entities.Exposed.WorldExposedExtensions.OnSystemCreated -= CreateBootstrapSystem;
            }

            protected override void OnUpdate()
            {
            }

            void CreateBootstrapSystem(World world, ComponentSystemBase system)
            {
                if (world != World)
                    return;

                if (system == this)
                    return;

                bootstrapRan                                                   = true;
                Unity.Entities.Exposed.WorldExposedExtensions.OnSystemCreated -= CreateBootstrapSystem;

                world.CreateSystem<CustomConversionBootstrapSystem>();
            }
        }

        [DisableAutoCreation]
        public class CustomConversionBootstrapSystem : GameObjectConversionSystem
        {
            public CustomConversionSettings customConversionSettings { get; private set; }

            protected override void OnCreate()
            {
                base.OnCreate();

                IEnumerable<System.Type> bootstrapTypes;
#if UNITY_EDITOR
                bootstrapTypes = UnityEditor.TypeCache.GetTypesDerivedFrom(typeof(ICustomConversionBootstrap));
#else

                var types = new List<System.Type>();
                var type  = typeof(ICustomConversionBootstrap);
                foreach (var assembly in System.AppDomain.CurrentDomain.GetAssemblies())
                {
                    if (!BootstrapTools.IsAssemblyReferencingLatios(assembly))
                        continue;

                    try
                    {
                        var assemblyTypes = assembly.GetTypes();
                        foreach (var t in assemblyTypes)
                        {
                            if (type.IsAssignableFrom(t))
                                types.Add(t);
                        }
                    }
                    catch (ReflectionTypeLoadException e)
                    {
                        foreach (var t in e.Types)
                        {
                            if (t != null && type.IsAssignableFrom(t))
                                types.Add(t);
                        }

                        UnityEngine.Debug.LogWarning($"ConversionWorldBootstrap failed loading assembly: {(assembly.IsDynamic ? assembly.ToString() : assembly.Location)}");
                    }
                }

                bootstrapTypes = types;
#endif

                System.Type selectedType = null;

                foreach (var bootType in bootstrapTypes)
                {
                    if (bootType.IsAbstract || bootType.ContainsGenericParameters)
                        continue;

                    if (selectedType == null)
                        selectedType = bootType;
                    else if (selectedType.IsAssignableFrom(bootType))
                        selectedType = bootType;
                    else if (!bootType.IsAssignableFrom(selectedType))
                        UnityEngine.Debug.LogError("Multiple custom ICustomConversionBootstrap exist in the project, ignoring " + bootType);
                }
                if (selectedType == null)
                    return;

                ICustomConversionBootstrap bootstrap = System.Activator.CreateInstance(selectedType) as ICustomConversionBootstrap;

                var settingsProperty   = GetType().GetProperty("Settings", BindingFlags.Instance | BindingFlags.NonPublic);
                var settingsObject     = settingsProperty.GetValue(this);
                var settings           = settingsObject as GameObjectConversionSettings;
                var settingsType       = settings.GetType();
                var conversionAssembly = settingsType.Assembly;

                var incremental    = World.GetOrCreateSystem(conversionAssembly.GetType("Unity.Entities.ConversionSetupGroup")) as ComponentSystemGroup;
                var declareConvert = World.GetOrCreateSystem<GameObjectDeclareReferencedObjectsGroup>();
                var earlyConvert   = World.GetOrCreateSystem<GameObjectBeforeConversionGroup>();
                var convert        = World.GetOrCreateSystem<GameObjectConversionGroup>();
                var lateConvert    = World.GetOrCreateSystem<GameObjectAfterConversionGroup>();

                var export = settings.SupportsExporting ? World.GetOrCreateSystem<GameObjectExportGroup>() : null;

                {
                    // for various reasons, this system needs to be present before any other system initializes
                    var system = World.GetOrCreateSystem(conversionAssembly.GetType("Unity.Entities.IncrementalChangesSystem"));
                    incremental.AddSystemToUpdateList(system);
                }

                var baseSystemTypes    = settings.Systems ?? DefaultWorldInitialization.GetAllSystems(settings.FilterFlags);
                var filteredSystemsSet = new HashSet<System.Type>();
                foreach (var system in baseSystemTypes)
                    filteredSystemsSet.Add(system);
                foreach (var system in settings.ExtraSystems)
                    filteredSystemsSet.Add(system);

                // Todo: Assuming the filter flags are not set to All so we don't have to remove the [DisableAutoCreation] systems we just created.
                var filteredSystems = new List<System.Type>(filteredSystemsSet);

                CustomConversionSettings customSettings = new CustomConversionSettings
                {
                    destinationWorld                   = settings.DestinationWorld,
                    sceneGUID                          = settings.SceneGUID,
                    debugConversionName                = settings.DebugConversionName,
                    conversionFlags                    = settings.ConversionFlags,
                    OnPostCreateConversionWorldWrapper = new OnPostCreateConversionWorldEventWrapper(),

#if UNITY_EDITOR
                    buildConfigurationGUID = settings.BuildConfigurationGUID,
                    buildConfiguration     = settings.BuildConfiguration,
                    assetImportContext     = settings.AssetImportContext,
                    prefabRoot             = settings.PrefabRoot
#endif
                };

                customConversionSettings = customSettings;
                bool createdSystems      = bootstrap.InitializeConversion(World, customSettings, ref filteredSystems);

                if (createdSystems)
                {
                    settings.Systems = new List<System.Type>();
                }
                else
                {
                    settings.Systems = filteredSystems;
                }
                settings.ExtraSystems            = System.Array.Empty<System.Type>();
                settings.ConversionWorldCreated += OnConversionWorldCreationFinished;
                m_settings                       = settings;
                m_ranCleanup                     = false;

                foreach (var system in World.Systems)
                {
                    if (!system.Enabled)
                        m_disableSet.Add(system);
                }
            }

            protected override void OnUpdate()
            {
            }

            GameObjectConversionSettings m_settings;
            bool                         m_ranCleanup = true;
            HashSet<ComponentSystemBase> m_disableSet = new HashSet<ComponentSystemBase>();

            protected override void OnDestroy()
            {
                if (!m_ranCleanup)
                    m_settings.ConversionWorldCreated -= OnConversionWorldCreationFinished;
                m_ranCleanup                           = true;
            }

            void OnConversionWorldCreationFinished(World world)
            {
                if (world == World)
                {
                    m_settings.ConversionWorldCreated -= OnConversionWorldCreationFinished;
                    m_ranCleanup                       = true;

                    if (m_disableSet.Count != 0)
                    {
                        foreach (var system in World.Systems)
                        {
                            if (m_disableSet.Contains(system))
                                system.Enabled = false;
                        }
                    }

                    customConversionSettings.InvokePostCreateConversionWorldEvent();
                }
            }
        }
    }
}

