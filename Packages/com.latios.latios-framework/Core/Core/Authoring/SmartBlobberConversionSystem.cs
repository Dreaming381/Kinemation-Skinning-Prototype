using Unity.Burst;
using Unity.Collections;
using Unity.Entities;
using Unity.Entities.LowLevel.Unsafe;
using Unity.Jobs;

namespace Latios.Authoring
{
    /// <summary>
    /// Implement this interface to request BlobAsset conversion from SmartBlobbers before
    /// they execute. You can then retrieve the results using IConvertGameObjectToEntity.
    /// </summary>
    public interface IRequestBlobAssets
    {
        void RequestBlobAssets(Entity entity, EntityManager dstEntityManager, GameObjectConversionSystem conversionSystem);
    }

    #region Handles
    /// <summary>
    /// A handle to a computed blob to be created by a smart blobber
    /// </summary>
    /// <typeparam name="TBlobType">The top of blob to be created</typeparam>
    public struct SmartBlobberHandle<TBlobType> where TBlobType : unmanaged
    {
        internal ISmartBlobberHandleResolver<TBlobType> m_resolver;
        internal int                                    m_index;

        /// <summary>
        /// Retrieves the blob asset after the smart blobber has run. Throws an exception if called before the smart blobber has run.
        /// </summary>
        /// <returns>The blob asset generated by the smart blobber</returns>
        public BlobAssetReference<TBlobType> Resolve()
        {
            if (m_resolver == null)
                throw new System.InvalidOperationException("This handle has not been initialized.");

            if (!m_resolver.HasProcessed(m_index))
                throw new System.InvalidOperationException(
                    $"The smart blobber of type {m_resolver.GetType().FullName} has not processed the blob yet. Please request the blob generation prior to smart blobber execution such as in DeclareReferencedPrefabs() and do not attempt to resolve the blob until hafter smart blobber execution such as in Convert().");

            return m_resolver.Resolve(m_index);
        }

        /// <summary>
        /// Returns true if this handle was generated by a smart blobber.
        /// </summary>
        public bool IsValid => m_resolver != null;
    }

    /// <summary>
    /// A handle to a computed blob to be created by a smart blobber
    /// </summary>
    public struct SmartBlobberHandleUntyped
    {
        internal ISmartBlobberHandleResolverUntyped m_resolver;
        internal int                                m_index;

        /// <summary>
        /// Retrieves the blob asset after the smart blobber has run. Throws an exception if called before the smart blobber has run.
        /// </summary>
        /// <returns>The blob asset generated by the smart blobber</returns>
        public UnsafeUntypedBlobAssetReference Resolve()
        {
            if (m_resolver == null)
                throw new System.InvalidOperationException("This handle has not been initialized.");

            if (!m_resolver.HasProcessed(m_index))
                throw new System.InvalidOperationException(
                    $"The smart blobber of type {m_resolver.GetType().FullName} has not processed the blob yet. Please request the blob generation prior to smart blobber execution such as in DeclareReferencedPrefabs() and do not attempt to resolve the blob until hafter smart blobber execution such as in Convert().");

            return m_resolver.ResolveUntyped(m_index);
        }

        /// <summary>
        /// Returns true if this handle was generated by a smart blobber.
        /// </summary>
        public bool IsValid => m_resolver != null;
    }
    #endregion
}

namespace Latios.Authoring.Systems
{
    #region BuilderInterfaces
    /// <summary>
    /// Implement this interface on a struct for simple Smart Blobber Conversion.
    /// This struct gets stored in a NativeArray and passed to a parallel job.
    /// If you need dynamically sized arrays of data for the blob, use UnsafeList
    /// allocated with World.UpdateAllocator.ToAllocator. You do not have to dispose
    /// such lists.
    /// </summary>
    /// <typeparam name="TBlobType">The root type of the Blob Asset</typeparam>
    public interface ISmartBlobberSimpleBuilder<TBlobType> where TBlobType : unmanaged
    {
        public BlobAssetReference<TBlobType> BuildBlob();
    }

    /// <summary>
    /// Implement this interface on a struct for advanced Smart Blobber Conversion.
    /// This struct gets stored in a NativeArray and passed to a parallel job.
    /// You can store shared data for all builders inside the context object.
    /// This is especially useful for MeshDataArrays or NativeHashMaps.
    /// </summary>
    /// <typeparam name="TBlobType">The root type of the Blob Asset</typeparam>
    /// <typeparam name="TContextType">The type of context object. This object can store NativeContainers and parallel job attributes apply.</typeparam>
    public interface ISmartBlobberContextBuilder<TBlobType, TContextType> where TBlobType : unmanaged where TContextType : struct
    {
        /// <summary>
        /// Build a blob asset using a context
        /// </summary>
        /// <param name="prefilterIndex">Corresponds to the indices in FilterBlobberData</param>
        /// <param name="postfilterIndex">Corresponds to the indices in PostFilterBlobberData</param>
        /// <param name="context">The context object shared across all converters</param>
        /// <returns></returns>
        public BlobAssetReference<TBlobType> BuildBlob(int prefilterIndex, int postfilterIndex, ref TContextType context);
    }

    // Unity does not cache blobs and hashes between conversions, meaning hashes only help deduplicate identical assets.
    // Smart blobbers have their own mechanism for deduplication at the input side, so using hashes only to deduplicate
    // final blob assets is sufficient. Therefore, pre-hashing rarely offsets its own cost and complexity.
    /*public interface ISmartBlobberHashBuilder<TBlobType, TContextType> where TBlobType : unmanaged where TContextType : struct
       {
        public Hash128 ComputeHash(int prefilterIndex, int postfilterIndex, ref TContextType context);
       }*/
    #endregion

    #region BaseClasses
    /// <summary>
    /// This is the simplest smart blobber type. Subclass this to create a smart blobber that only reasons about each blob asset individually.
    /// </summary>
    /// <typeparam name="TBlobType">The type of blob this smart blobber generates</typeparam>
    /// <typeparam name="TManagedInputType">A struct containing authoring data possibly including managed references</typeparam>
    /// <typeparam name="TUnmanagedConversionType">A struct which contains the necessary unmanaged data and functions for creating a BlobAsset. It's method will be executed in a Burst job.</typeparam>
    /// <remarks>
    /// A Smart Blobber is a GameObjectConversionSystem which acts as a blob asset generation service for other conversion logic.
    /// MonoBehaviours implementing IRequestBlobAssets and conversion systems updating in GameObjectBeforeConversionGroup can request blob asset conversion
    /// for a given input. Requests are responded with a handle that can be resolved during GameObjectConversionGroup or IConvertGameObjectToEntity.
    /// Smart Blobbers can also iterate authoring entities and add components to converted entities.
    /// Smart blobbers will try to parallelize as much of the blob asset conversion as possible. They handle BlobAssetStore and BlobAssetComputationContext
    /// internally. You do not need to worry about these things. Just implement the required functions and interfaces and you should be good to go.
    /// </remarks>
    [UpdateInGroup(typeof(SmartBlobberConversionGroup))]
    public abstract partial class SmartBlobberConversionSystem<TBlobType, TManagedInputType, TUnmanagedConversionType> : GameObjectConversionSystem
        where TBlobType : unmanaged
        where TManagedInputType : struct
        where TUnmanagedConversionType : unmanaged, ISmartBlobberSimpleBuilder<TBlobType>
    {
        /// <summary>
        /// Add an input to convert to a BlobAsset as well as the unityObject the blob should be associated with. Can only be called before the system is updated or during GatherInputs().
        /// </summary>
        /// <param name="gameObject">The converted GameObject to associate the blob with, throws if null. This object should have an entity associated with it.</param>
        /// <param name="input">Input data which can be used to gather everything needed to generate a blob</param>
        /// <returns>A handle which can be resolved into a BlobAssetReference after the smart blobber runs</returns>
        public SmartBlobberHandle<TBlobType> AddToConvert(UnityEngine.GameObject gameObject, in TManagedInputType input)
        {
            if (m_inputsAreLocked)
            {
                throw new System.InvalidOperationException("You cannot call AddToConvert() during Filter()");
            }

            if (gameObject == null)
            {
                throw new System.ArgumentNullException("unityObject cannot be null");
            }

            int index                                          = m_inputs.Count + m_handleToOutputIndices.Count;
            m_inputs.Add(new InputElement { gameObject         = gameObject, input = input });
            return new SmartBlobberHandle<TBlobType> { m_index = index, m_resolver = this };
        }

        /// <summary>
        /// Add an input to convert to a BlobAsset as well as the unityObject the blob should be associated with. Can only be called before the system is updated or during GatherInputs().
        /// </summary>
        /// <param name="gameObject">The converted GameObject to associate the blob with, throws if null. This object should have an entity associated with it.</param>
        /// <param name="input">Input data which can be used to gather everything needed to generate a blob</param>
        /// <returns>A handle which can be resolved into a BlobAssetReference after the smart blobber runs</returns>
        public SmartBlobberHandleUntyped AddToConvertUntyped(UnityEngine.GameObject gameObject, in TManagedInputType input)
        {
            if (m_inputsAreLocked)
            {
                throw new System.InvalidOperationException("You cannot call AddToConvertUntyped() during Filter()");
            }

            if (gameObject == null)
            {
                throw new System.ArgumentNullException("unityObject cannot be null");
            }

            int index                                      = m_inputs.Count + m_handleToOutputIndices.Count;
            m_inputs.Add(new InputElement { gameObject     = gameObject, input = input });
            return new SmartBlobberHandleUntyped { m_index = index, m_resolver = this };
        }

        /// <summary>
        /// Override this function to collect additional inputs using AddToConvert() and AddToConvertUntyped().
        /// </summary>
        protected virtual void GatherInputs()
        {
        }

        /// <summary>
        /// Generate a converter instance to generate a Blob Asset. You must override this function. Return false to skip the input.
        /// </summary>
        /// <param name="input">The managed input</param>
        /// <param name="gameObject">The GameObject which is being converted.</param>
        /// <param name="converter">The unmanaged data required to generate a Blob Asset. The converter will be executed in a Burst job.</param>
        /// <returns>Returns false if skipped and true if kept.</returns>
        protected abstract bool Filter(in TManagedInputType input, UnityEngine.GameObject gameObject, out TUnmanagedConversionType converter);

        /// <summary>
        /// Override this function to process any handles created during GatherInputs().
        /// </summary>
        protected virtual void FinalizeOutputs()
        {
        }
    }

    /// <summary>
    /// This is a smart blobber type that provides a context object which can use NativeContainers and is accessible by all converters.
    /// It also provides a more advanced input filtering API which can perform initial deduplication.
    /// Subclass this when you need a smart blobber that can reason about more than one blob asset at a time.
    /// </summary>
    /// <typeparam name="TBlobType">The type of blob this smart blobber generates</typeparam>
    /// <typeparam name="TManagedInputType">A struct containing authoring data possibly including managed references</typeparam>
    /// <typeparam name="TUnmanagedConversionType">A struct which contains the necessary unmanaged data and functions for creating a BlobAsset. It's method will be executed in a Burst job.</typeparam>
    /// <typeparam name="TContextType">A struct which may use NativeContainers and is provided to all the converters.</typeparam>
    [UpdateInGroup(typeof(SmartBlobberConversionGroup))]
    public abstract partial class SmartBlobberConversionSystem<TBlobType, TManagedInputType, TUnmanagedConversionType, TContextType> : GameObjectConversionSystem
        where TBlobType : unmanaged
        where TManagedInputType : struct
        where TUnmanagedConversionType : unmanaged, ISmartBlobberContextBuilder<TBlobType, TContextType>
        where TContextType : struct, System.IDisposable
    {
        /// <summary>
        /// Add an input to convert to a BlobAsset as well as the unityObject the blob should be associated with. Can only be called before the system is updated or during GatherInputs().
        /// </summary>
        /// <param name="gameObject">The converted GameObject to associate the blob with, throws if null. This object should have an entity associated with it.</param>
        /// <param name="input">Input data which can be used to gather everything needed to generate a blob</param>
        /// <returns>A handle which can be resolved into a BlobAssetReference after the smart blobber runs</returns>
        public SmartBlobberHandle<TBlobType> AddToConvert(UnityEngine.GameObject gameObject, in TManagedInputType input)
        {
            if (m_inputsAreLocked)
            {
                throw new System.InvalidOperationException("You cannot call AddToConvert() during Filter()");
            }

            if (gameObject == null)
            {
                throw new System.ArgumentNullException("unityObject cannot be null");
            }

            int index                                          = m_inputs.Count + m_handleToOutputIndices.Count;
            m_inputs.Add(new InputElement { gameObject         = gameObject, input = input });
            return new SmartBlobberHandle<TBlobType> { m_index = index, m_resolver = this };
        }

        /// <summary>
        /// Add an input to convert to a BlobAsset as well as the unityObject the blob should be associated with. Can only be called before the system is updated or during GatherInputs().
        /// </summary>
        /// <param name="gameObject">The converted GameObject to associate the blob with, throws if null. This object should have an entity associated with it.</param>
        /// <param name="input">Input data which can be used to gather everything needed to generate a blob</param>
        /// <returns>A handle which can be resolved into a BlobAssetReference after the smart blobber runs</returns>
        public SmartBlobberHandleUntyped AddToConvertUntyped(UnityEngine.GameObject gameObject, in TManagedInputType input)
        {
            if (m_inputsAreLocked)
            {
                throw new System.InvalidOperationException("You cannot call AddToConvertUntyped() during Filter()");
            }

            if (gameObject == null)
            {
                throw new System.ArgumentNullException("unityObject cannot be null");
            }

            int index                                      = m_inputs.Count + m_handleToOutputIndices.Count;
            m_inputs.Add(new InputElement { gameObject     = gameObject, input = input });
            return new SmartBlobberHandleUntyped { m_index = index, m_resolver = this };
        }

        /// <summary>
        /// Override this function to collect additional inputs using AddToConvert() and AddToConvertUntyped().
        /// </summary>
        protected virtual void GatherInputs()
        {
        }

        /// <summary>
        /// Indexer-based mutable access to the <typeparamref name="TManagedInputType"/> array.
        /// </summary>
        public partial struct InputAccess
        {
            public TManagedInputType this[int index]
            {
                get => GetInput(index);
                set => SetInput(index, value);
            }
        }

        /// <summary>
        /// Indexer-based readonly access to the GameObject instances associated with the inputs
        /// </summary>
        public partial struct GameObjectAccess
        {
            public UnityEngine.GameObject this[int index]
            {
                get => GetInput(index);
            }
        }

        /// <summary>
        /// Contains access to inputs and converters during filtering
        /// </summary>
        public struct FilterBlobberData
        {
            /// <summary>
            /// Read-write access to the inputs <typeparamref name="TManagedInputType"/>
            /// </summary>
            public InputAccess input { get; internal set; }
            /// <summary>
            /// Readonly access to the associated UnityEngine.GameObjects being converted
            /// </summary>
            public GameObjectAccess associatedObject { get; internal set; }
            /// <summary>
            /// Read-write access to the converters <typeparamref name="TUnmanagedConversionType"/>. Values are completely uninitialized to begin with.
            /// The converters do not need to be initialized at this time.
            /// </summary>
            public NativeArray<TUnmanagedConversionType> converters { get; internal set; }

            public int Count => converters.Length;
        }

        /// <summary>
        /// Setup the converters and context using the inputs. Use the <paramref name="inputToFilteredMapping"/> to deduplicate or invalidate inputs.
        /// </summary>
        /// <param name="blobberData">Access to the inputs and converters</param>
        /// <param name="context">Global context object accessible to converters</param>
        /// <param name="inputToFilteredMapping">Set an element to a negative value to skip the corresponding input.
        /// Otherwise, set it to the index of the input to use, which must be equal or lower to the element index.
        /// Examples:
        ///     inputToFilteredMapping[2] = -1; - Discard the third input.
        ///     inputToFilteredMapping[3] = 3; - Use the fourth input as is.
        ///     inputTofilteredMapping[4] = 1; - Treat the fifth input as a duplicate of the second input. The fifth converter will not be executed.
        ///     inputToFilteredMapping[5] = 8; - Invalid. 8 is larger than 5.
        ///     inputToFilteredMapping[6] = 4; inputToFilteredMapping[7] = 6; - Invalid. Cannot mark duplicated of an input that is already marked duplicated.
        ///     </param>
        protected abstract void Filter(FilterBlobberData blobberData, ref TContextType context, NativeArray<int> inputToFilteredMapping);

        /// <summary>
        /// Contains access to inputs and converters after filtering but before the converters have been executed.
        /// The arrays have been compacted at this point and filtered out elements are no longer present.
        /// </summary>
        public struct PostFilterBlobberData
        {
            /// <summary>
            /// Read-write access to the inputs <typeparamref name="TManagedInputType"/>
            /// </summary>
            public InputAccess input { get; internal set; }
            /// <summary>
            /// Read-write access to the filtered converters <typeparamref name="TUnmanagedConversionType"/>. Values are completely uninitialized to begin with.
            /// If the converters were not initialized before, they must be initialized now.
            /// </summary>
            public NativeArray<TUnmanagedConversionType> converters { get; internal set; }
            /// <summary>
            /// Readonly access to the mapping from a filtered converter to the original input for manipulating the context object.
            /// </summary>
            public NativeArray<int>.ReadOnly filteredToInputMapping;

            public int Count => converters.Length;
        }

        /// <summary>
        /// Override this function to perform any additional preparation to the filtered list of converters and context. After this, the blob assets will be generated.
        /// </summary>
        /// <param name="blobberData">Access to the filtered subset of inputs and converters</param>
        /// <param name="context">Global context object accessible to converters</param>
        protected virtual void PostFilter(PostFilterBlobberData blobberData, ref TContextType context)
        {
        }

        /// <summary>
        /// Override this function to process any handles created during GatherInputs().
        /// </summary>
        protected virtual void FinalizeOutputs()
        {
        }
    }
    #endregion
}

